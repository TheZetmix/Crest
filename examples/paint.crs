[!include] {
    "stdio.h"
    "stdlib.h"
    "unistd.h"
    "ncurses.h"
}

var rows : int = 16;
var cols : int = 32;

struct Coord {
    x : int;
    y : int;
}

struct Trail {
    coords : *Coord;
    size : int;
    cap : int;
}

struct Player {
    x : int;
    y : int;
    trail : Trail;
}

fn trail_push(t : *Trail, x : int, y : int) : void {
    if (t->size >= t->cap) {
        t->cap += 16;
        t->coords = realloc(t->coords, (t->cap) * sizeof(Coord));
    }
    t->coords[t->size] = (Coord){x, y};
    t->size++;
}

fn get_coords(x : int, y : int) : int {
    return (y * cols + x);
}

fn render_sc(sc : *char) : void {
    werase(stdscr);
    for (i : int = 0; i < rows; ++i) {
        for (j : int = 0; j < cols; ++j) {
            printw("%c", sc[get_coords(j, i)] ? '@' : '.');
        }
        printw("\n");
    }
    refresh();
}

fn reset_sc(sc : *char) : void {
    for (i : int = 0; i < rows; ++i) {
        for (j : int = 0; j < cols; ++j) {
            *(sc+get_coords(j, i)) = 0;
        }
    }
}

fn main() : int {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    
    var sc : *char = malloc(rows * cols);
    var pl : Player = {cols/2, rows/2};
    while (1) {
        var inp : int = getch();
        if (inp == KEY_UP) {
            pl.y -= 1;
        } else if (inp == KEY_DOWN) {
            pl.y += 1;
        } else if (inp == KEY_LEFT) {
            pl.x -= 1;
        } else if (inp == KEY_RIGHT) {
            pl.x += 1;
        } else if (inp == 113) {
            break;
        }
        
        sc[get_coords(pl.x, pl.y)] = 1;
        trail_push(&pl.trail, pl.x, pl.y);
        
        for (i : int = 0; i < pl.trail.size; ++i) {
            sc[get_coords(pl.trail.coords[i].x, pl.trail.coords[i].y)] = 1;
        }
        
        render_sc(sc);
        reset_sc(sc);
        printw("%d", inp);
    }
    endwin();
}
